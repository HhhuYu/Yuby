%{
open Absyn

// Vardesc 返回的是一个 元组 (g,s)
// g是类型构造函数，s是变量名

let compose1 f (g, s) = ((fun x -> g(f(x))), s)
let nl = CstI 10
%}

%token <int> CSTINT
%token <string> CSTSTRING NAME


%token ELSE IF INT NIL PRINT RETURN WHILE ELSIF PUTS END THEN
%token PLUS MINUS TIMES DIV MOD POWER
%token EQ NE GT LT GE LE BELONG
%token NOT SEQOR SEQAND SEQAND2 SEQOR2 NOT2
%token LPAR RPAR LBRACE RBRACE LBRACK RBRACK SEMI COMMA ASSIGN AMP COLON NL DEF
%token EOF

%right ASSIGN             /* lowest precedence */
%nonassoc PRINT
%left SEQOR SEQOR2
%left SEQAND SEQAND2
%left EQ NE BELONG
%nonassoc GT LT GE LE 
%left PLUS MINUS
%left TIMES DIV MOD 
%left POWER                /* power precedence */
%nonassoc NOT AMP 
%nonassoc LBRACK          /* highest precedence  */

%start Main
%type <Absyn.program> Main 

%%

Main:
    Topdecs EOF                         { Prog $1 }
;

Topdecs:
    /* empty */                         { [] }
  | NL                                  {    }
  | Topdec Topdecs                      { $1 :: $2 }
;

Topdec: 
   NL                                   {   }
  | Vardec SEMI                         { Vardec (fst $1, snd $1) }
  | Vardec NL                           { Vardec (fst $1, snd $1) }
  | Fundec                              { $1 }
  | Classdec                            { $1 }
;

Vardec:
  NL                                    {                       }
  | Vardesc                             { ($1)                  }
;

Vardesc: 
  NL                                    {                                         }
  | NAME                                { ((fun t -> t), $1)                      }
  | LPAR Vardesc RPAR                   { $2                                      } 
  | Vardesc LBRACK RBRACK               { compose1 (fun t -> TypA(t, None)) $1    }
  | Vardesc LBRACK CSTINT RBRACK        { compose1 (fun t -> TypA(t, Some $3)) $1 }
;

Fundec:
  NL                                       {                    }
  | DEF NAME LPAR Paramdecs RPAR Block END { Fundec($2, $4, $6) }
  | DEF NAME Block END                     { Fundec($2,  NIL, $3) }
;

Classdec:
  DEF NAME Block END                    { Classdec($2,$3)}

Paramdecs:
    /* empty */                         { [] }
  | Paramdecs1                          { $1 }
;

Paramdecs1:
  | Vardec                              { [$1]     }
  | Vardec COMMA Paramdecs1             { $1 :: $3 }
;

Block:
  NL                                    {          }
  | LBRACE StmtOrDecSeq RBRACE          { Block $2 }
  | StmtOrDecSeq                        { Block $2 }
;

StmtOrDecSeq:
    /* empty */                         { [] }
  |NL                                   {               }
  | Stmt StmtOrDecSeq                   { Stmt $1 :: $2 }
  | Vardec SEMI StmtOrDecSeq            { Dec (fst $1, snd $1) :: $3 }
  | Vardec NL StmtOrDecSeq              { Dec (fst $1, snd $1) :: $3 }
;

Stmt: 
    StmtM                               { $1 }
  | StmtU                               { $1 }
;

StmtM:  /* No unbalanced if-else */
  NL                                    {                      }
  | Expr SEMI                           { Expr($1)             }
  | Expr NL                             { Expr($1)             }
  | Expr                                { Expr($1)             }
  //| RETURN SEMI                       { Return None          }
  | RETURN Expr SEMI                    { Return(Some($2))     }
  | RETURN Expr NL                      { Return(Some($2))     }
  | Block                               { $1                   }
  | IF Expr StmtM ELSE StmtM END        { If($2, $3, $5)       }
  | IF Expr THEN StmtM ELSE StmtM END   { If($2, $4, $6)       }
  | WHILE Expr StmtM END                { While($2, $3)        }
  | WHILE Expr THEN StmtM END           { While($2, $4)        }
;

StmtU:
 NL                                     {                      }
  | IF Expr StmtM ELSE StmtU END        { If($2, $3, $5)       }
  | IF Expr THEN Stmt END               { If($2, $4, Block []) }
  | WHILE Expr StmtU END                { While($2, $3)        }
  | WHILE Expr THEN StmtM END           { While($2, $3)        }
;

Expr: 
    Access                              { Access $1           }
  | ExprNotAccess                       { $1                  }
;

ExprNotAccess:
  NL                                    {                     }
  | Access ASSIGN Expr                  { Assign($1, $3)      }
  | NAME LPAR Exprs RPAR                { Call($1, $3)        }  
  | NOT Expr                            { Prim1("!", $2)      }
  | PRINT Expr                          { Prim1("printi", $2) }
  | PUTS Expr                           { Prim1("puts",$2+nl )}
  | Expr PLUS  Expr                     { Prim2("+",  $1, $3) }
  | Expr MINUS Expr                     { Prim2("-",  $1, $3) }
  | Expr TIMES Expr                     { Prim2("*",  $1, $3) }
  | Expr DIV   Expr                     { Prim2("/",  $1, $3) }
  | Expr MOD   Expr                     { Prim2("%",  $1, $3) }
  | Expr EQ    Expr                     { Prim2("==", $1, $3) }
  | Expr NE    Expr                     { Prim2("!=", $1, $3) }
  | Expr GT    Expr                     { Prim2(">",  $1, $3) }
  | Expr LT    Expr                     { Prim2("<",  $1, $3) }
  | Expr GE    Expr                     { Prim2(">=", $1, $3) }
  | Expr LE    Expr                     { Prim2("<=", $1, $3) }
  | Expr SEQAND Expr                    { Andalso($1, $3)     }
  | Expr SEQAND2 Expr                   { Andalso($1, $3)     }
  | Expr SEQOR  Expr                    { Orelse($1, $3)      }
  | Expr SEQOR2  Expr                   { Orelse($1, $3)      }
;

Access:
  | NAME                                { AccVar $1           }
  | LPAR Access RPAR                    { $2                  }  
  | Access LBRACK Expr RBRACK           { AccIndex($1, $3)    }   
;

Exprs:
    /* empty */                         { []       }
  | Exprs1                              { $1       }
;

Exprs1:
  | Expr                                { [$1]     }
  | Expr COMMA Exprs1                   { $1 :: $3 }
;

Const:
    CSTINT                              { $1       }
  | MINUS CSTINT                        { - $2     }
  | NIL                                 { -1       }
;

Type:
    INT                                 { TypI     }
;
